-- @testpoint: upsert子查询select基础语法覆盖，不符合语法要求，合理报错
--创建upeset及子查询表，插入数据
drop table if exists t_dml_upsert_sub0127;
SQL SUCCESS
create table t_dml_upsert_sub0127 (a int,b int primary key,c text);
SQL SUCCESS
insert into t_dml_upsert_sub0127 values(generate_series(1,10),generate_series(1,10),'c-'||generate_series(1,10));
SQL SUCCESS
insert into t_dml_upsert_sub0127 values(generate_series(1,10),generate_series(11,20),'c-'||generate_series(1,10));
SQL SUCCESS
insert into t_dml_upsert_sub0127 values('',generate_series(21,30),'c-'||generate_series(1,10));
SQL SUCCESS
drop table if exists t_dml_upsert0127;
SQL SUCCESS
--创建upsert表，组合主键场景
create table t_dml_upsert0127 (a int , b text, c int not null, d text,primary key (a,b));
SQL SUCCESS
insert into t_dml_upsert0127 values (1,1,1),(2,2,2),(3,3,3),(4,4,4);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 1 | 1 | 1 |   |
| 2 | 2 | 2 |   |
| 3 | 3 | 3 |   |
| 4 | 4 | 4 |   |
+---+---+---+---+
analyze t_dml_upsert_sub0127;
SQL SUCCESS
analyze t_dml_upsert0127;
SQL SUCCESS
--distinct， muilt-set/single-set均支持
explain (costs off, verbose) select distinct(c),a from t_dml_upsert_sub0127 where a=4;
+-----------------------------------------------------+
| QUERY PLAN                                          |
+-----------------------------------------------------+
| Unique                                              |
|   Output: c, a                                      |
|   ->  Sort                                          |
|         Output: c, a                                |
|         Sort Key: t_dml_upsert_sub0127.c            |
|         ->  Seq Scan on public.t_dml_upsert_sub0127 |
|               Output: c, a                          |
|               Filter: (t_dml_upsert_sub0127.a = 4)  |
+-----------------------------------------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= (select distinct(c),a from t_dml_upsert_sub0127 where a=4);
+--------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                       |
+--------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                                |
|   Conflict Resolution: UPDATE                                                                    |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                                |
|   InitPlan 1 (returns $0)                                                                        |
|     ->  Subquery Scan on "S"                                                                     |
|           Output: "S".s2                                                                         |
|           ->  Unique                                                                             |
|                 Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a             |
|                 ->  Sort                                                                         |
|                       Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a       |
|                       Sort Key: public.t_dml_upsert_sub0127.c                                    |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                             Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a |
|                             Filter: (public.t_dml_upsert_sub0127.a = 4)                          |
|   InitPlan 2 (returns $1)                                                                        |
|     ->  Subquery Scan on "S"                                                                     |
|           Output: "S".s1                                                                         |
|           ->  Unique                                                                             |
|                 Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a             |
|                 ->  Sort                                                                         |
|                       Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a       |
|                       Sort Key: public.t_dml_upsert_sub0127.c                                    |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                             Output: public.t_dml_upsert_sub0127.c, public.t_dml_upsert_sub0127.a |
|                             Filter: (public.t_dml_upsert_sub0127.a = 4)                          |
|   ->  Result                                                                                     |
|         Output: 1, '1'::text, 3, NULL::text                                                      |
+--------------------------------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= (select distinct(c),a from t_dml_upsert_sub0127 where a=4);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 2 | 2 | 2 |     |
| 3 | 3 | 3 |     |
| 4 | 4 | 4 |     |
| 1 | 1 | 4 | c-4 |
+---+---+---+-----+
explain (costs off, verbose) select distinct(c) from t_dml_upsert_sub0127 where a=5;
+-----------------------------------------------+
| QUERY PLAN                                    |
+-----------------------------------------------+
| HashAggregate                                 |
|   Output: c                                   |
|   Group By Key: t_dml_upsert_sub0127.c        |
|   ->  Seq Scan on public.t_dml_upsert_sub0127 |
|         Output: c                             |
|         Filter: (t_dml_upsert_sub0127.a = 5)  |
+-----------------------------------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select distinct(c) from t_dml_upsert_sub0127 where a=5);
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| Insert on public.t_dml_upsert0127                     |
|   Conflict Resolution: UPDATE                         |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey     |
|   InitPlan 1 (returns $0)                             |
|     ->  HashAggregate                                 |
|           Output: t_dml_upsert_sub0127.c              |
|           Group By Key: t_dml_upsert_sub0127.c        |
|           ->  Seq Scan on public.t_dml_upsert_sub0127 |
|                 Output: t_dml_upsert_sub0127.c        |
|                 Filter: (t_dml_upsert_sub0127.a = 5)  |
|   ->  Result                                          |
|         Output: 1, '1'::text, 3, NULL::text           |
+-------------------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select distinct(c) from t_dml_upsert_sub0127 where a=5);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 2 | 2 | 2 |     |
| 3 | 3 | 3 |     |
| 4 | 4 | 4 |     |
| 1 | 1 | 4 | c-5 |
+---+---+---+-----+
--plain hint ，目前存在问题，待开发核实
--indexscan 方式的hint
explain (costs off, verbose) select /*+ indexscan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1;
+---------------------------------------------------------------------------+
| QUERY PLAN                                                                |
+---------------------------------------------------------------------------+
| Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|   Output: c, a                                                            |
|   Index Cond: (t_dml_upsert_sub0127.b > 1)                                |
|   Filter: (t_dml_upsert_sub0127.a = 1)                                    |
+---------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= ( select /*+ indexscan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= ( select /*+ indexscan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1);
+-------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                      |
+-------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                               |
|   Conflict Resolution: UPDATE                                                                   |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                               |
|   InitPlan 1 (returns $0)                                                                       |
|     ->  Seq Scan on public.t_dml_upsert_sub0127                                                 |
|           Output: public.t_dml_upsert_sub0127.a                                                 |
|           Filter: ((public.t_dml_upsert_sub0127.b > 1) AND (public.t_dml_upsert_sub0127.a = 1)) |
|   InitPlan 2 (returns $1)                                                                       |
|     ->  Seq Scan on public.t_dml_upsert_sub0127                                                 |
|           Output: public.t_dml_upsert_sub0127.c                                                 |
|           Filter: ((public.t_dml_upsert_sub0127.b > 1) AND (public.t_dml_upsert_sub0127.a = 1)) |
|   ->  Result                                                                                    |
|         Output: 1, '1'::text, 3, NULL::text                                                     |
+-------------------------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 2 | 2 | 2 |     |
| 3 | 3 | 3 |     |
| 4 | 4 | 4 |     |
| 1 | 1 | 1 | c-1 |
+---+---+---+-----+
--tablescan 方式的hint
explain (costs off, verbose) select /*+ tablescan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1;
+---------------------------------------------------------------------------+
| QUERY PLAN                                                                |
+---------------------------------------------------------------------------+
| Seq Scan on public.t_dml_upsert_sub0127                                   |
|   Output: c, a                                                            |
|   Filter: ((t_dml_upsert_sub0127.b > 1) AND (t_dml_upsert_sub0127.a = 1)) |
+---------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= ( select /*+ tablescan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (d,c)= ( select /*+ tablescan(t_dml_upsert_sub0127)*/ c,a from t_dml_upsert_sub0127 where b>1 and a=1);
+-------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                      |
+-------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                               |
|   Conflict Resolution: UPDATE                                                                   |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                               |
|   InitPlan 1 (returns $0)                                                                       |
|     ->  Seq Scan on public.t_dml_upsert_sub0127                                                 |
|           Output: public.t_dml_upsert_sub0127.a                                                 |
|           Filter: ((public.t_dml_upsert_sub0127.b > 1) AND (public.t_dml_upsert_sub0127.a = 1)) |
|   InitPlan 2 (returns $1)                                                                       |
|     ->  Seq Scan on public.t_dml_upsert_sub0127                                                 |
|           Output: public.t_dml_upsert_sub0127.c                                                 |
|           Filter: ((public.t_dml_upsert_sub0127.b > 1) AND (public.t_dml_upsert_sub0127.a = 1)) |
|   ->  Result                                                                                    |
|         Output: 1, '1'::text, 3, NULL::text                                                     |
+-------------------------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 2 | 2 | 2 |     |
| 3 | 3 | 3 |     |
| 4 | 4 | 4 |     |
| 1 | 1 | 1 | c-1 |
+---+---+---+-----+
--limit,muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (c,d) = (select c,b from t_dml_upsert_sub0127 where a>4 limit 1);
?.*ERROR: syntax error at or near "limit"
?.*
explain (costs off, verbose) select c from t_dml_upsert_sub0127 where a>4 limit 1;
+-----------------------------------------------+
| QUERY PLAN                                    |
+-----------------------------------------------+
| Limit                                         |
|   Output: c                                   |
|   ->  Seq Scan on public.t_dml_upsert_sub0127 |
|         Output: c                             |
|         Filter: (t_dml_upsert_sub0127.a > 4)  |
+-----------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where a>4 limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 2 | 2 | 2 |     |
| 3 | 3 | 3 |     |
| 4 | 4 | 4 |     |
| 1 | 1 | 1 | c-5 |
+---+---+---+-----+
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where a>4 limit 1);
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| Insert on public.t_dml_upsert0127                     |
|   Conflict Resolution: UPDATE                         |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey     |
|   InitPlan 1 (returns $0)                             |
|     ->  Limit                                         |
|           Output: t_dml_upsert_sub0127.c              |
|           ->  Seq Scan on public.t_dml_upsert_sub0127 |
|                 Output: t_dml_upsert_sub0127.c        |
|                 Filter: (t_dml_upsert_sub0127.a > 4)  |
|   ->  Result                                          |
|         Output: 1, '1'::text, 3, NULL::text           |
+-------------------------------------------------------+
--limit offset，muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (c,d)= (select c,b from t_dml_upsert_sub0127 where a>4 limit 1 offset 5);
?.*ERROR: syntax error at or near "limit"
?.*
explain (costs off, verbose) select c from t_dml_upsert_sub0127 where a>4 limit 1 offset 5;
+-----------------------------------------------+
| QUERY PLAN                                    |
+-----------------------------------------------+
| Limit                                         |
|   Output: c                                   |
|   ->  Seq Scan on public.t_dml_upsert_sub0127 |
|         Output: c                             |
|         Filter: (t_dml_upsert_sub0127.a > 4)  |
+-----------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where a>4 limit 1 offset 5);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+------+
| a | b | c | d    |
+---+---+---+------+
| 2 | 2 | 2 |      |
| 3 | 3 | 3 |      |
| 4 | 4 | 4 |      |
| 1 | 1 | 1 | c-10 |
+---+---+---+------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where a>4 limit 1 offset 5);
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| Insert on public.t_dml_upsert0127                     |
|   Conflict Resolution: UPDATE                         |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey     |
|   InitPlan 1 (returns $0)                             |
|     ->  Limit                                         |
|           Output: t_dml_upsert_sub0127.c              |
|           ->  Seq Scan on public.t_dml_upsert_sub0127 |
|                 Output: t_dml_upsert_sub0127.c        |
|                 Filter: (t_dml_upsert_sub0127.a > 4)  |
|   ->  Result                                          |
|         Output: 1, '1'::text, 3, NULL::text           |
+-------------------------------------------------------+
--offset，muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (c,d)= (select c,b from t_dml_upsert_sub0127 where a>4 offset 5);
?.*ERROR: syntax error at or near "offset"
?.*
explain (costs off, verbose) select b from t_dml_upsert_sub0127 where b>4 and a =10 order by b asc offset 1;
+----------------------------------------------------------------------------------------+
| QUERY PLAN                                                                             |
+----------------------------------------------------------------------------------------+
| Limit                                                                                  |
|   Output: b                                                                            |
|   ->  Sort                                                                             |
|         Output: b                                                                      |
|         Sort Key: t_dml_upsert_sub0127.b                                               |
|         ->  Seq Scan on public.t_dml_upsert_sub0127                                    |
|               Output: b                                                                |
|               Filter: ((t_dml_upsert_sub0127.b > 4) AND (t_dml_upsert_sub0127.a = 10)) |
+----------------------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select b from t_dml_upsert_sub0127 where b>4 and a =10 order by b asc offset 1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d = (select b from t_dml_upsert_sub0127 where b>4 and a =10 order by b asc offset 1);
+------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                     |
+------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                              |
|   Conflict Resolution: UPDATE                                                                  |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                              |
|   InitPlan 1 (returns $0)                                                                      |
|     ->  Limit                                                                                  |
|           Output: t_dml_upsert_sub0127.b                                                       |
|           ->  Sort                                                                             |
|                 Output: t_dml_upsert_sub0127.b                                                 |
|                 Sort Key: t_dml_upsert_sub0127.b                                               |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                                    |
|                       Output: t_dml_upsert_sub0127.b                                           |
|                       Filter: ((t_dml_upsert_sub0127.b > 4) AND (t_dml_upsert_sub0127.a = 10)) |
|   ->  Result                                                                                   |
|         Output: 1, '1'::text, 3, NULL::text                                                    |
+------------------------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+----+
| a | b | c | d  |
+---+---+---+----+
| 2 | 2 | 2 |    |
| 3 | 3 | 3 |    |
| 4 | 4 | 4 |    |
| 1 | 1 | 1 | 20 |
+---+---+---+----+
--FETCH，muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update (c,d)= (select c,b from t_dml_upsert_sub0127 where b>4 offset 2 fetch next 1 row only);
?.*ERROR: syntax error at or near "offset"
?.*
explain (costs off, verbose) select b from t_dml_upsert_sub0127 where b>4 offset 2 fetch next 1 row only;
+-----------------------------------------------+
| QUERY PLAN                                    |
+-----------------------------------------------+
| Limit                                         |
|   Output: b                                   |
|   ->  Seq Scan on public.t_dml_upsert_sub0127 |
|         Output: b                             |
|         Filter: (t_dml_upsert_sub0127.b > 4)  |
+-----------------------------------------------+
insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 where b>4 offset 2 fetch next 1 row only);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 2 | 2 | 2 |   |
| 3 | 3 | 3 |   |
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
+---+---+---+---+
explain (costs off, verbose) insert into t_dml_upsert0127 values(1,1,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 where b>4 offset 2 fetch next 1 row only);
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| Insert on public.t_dml_upsert0127                     |
|   Conflict Resolution: UPDATE                         |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey     |
|   InitPlan 1 (returns $0)                             |
|     ->  Limit                                         |
|           Output: t_dml_upsert_sub0127.b              |
|           ->  Seq Scan on public.t_dml_upsert_sub0127 |
|                 Output: t_dml_upsert_sub0127.b        |
|                 Filter: (t_dml_upsert_sub0127.b > 4)  |
|   ->  Result                                          |
|         Output: 1, '1'::text, 3, NULL::text           |
+-------------------------------------------------------+
--order by ，muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select c,b from t_dml_upsert_sub0127 where b=4 order by b ASC);
?.*ERROR: syntax error at or near "order"
?.*
explain (costs off, verbose) select a from t_dml_upsert_sub0127 where b=4 order by b ASC;
+---------------------------------------------------------------------------+
| QUERY PLAN                                                                |
+---------------------------------------------------------------------------+
| [Bypass]                                                                  |
| Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|   Output: a, b                                                            |
|   Index Cond: (t_dml_upsert_sub0127.b = 4)                                |
+---------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update c= (select a from t_dml_upsert_sub0127 where b=4 order by b ASC);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 3 | 3 | 3 |   |
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
| 2 | 2 | 4 |   |
+---+---+---+---+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d= (select c from t_dml_upsert_sub0127 where b=4 order by b ASC);
+-----------------------------------------------------------------------------------+
| QUERY PLAN                                                                        |
+-----------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                 |
|   Conflict Resolution: UPDATE                                                     |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                 |
|   InitPlan 1 (returns $0)                                                         |
|     ->  Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|           Output: t_dml_upsert_sub0127.c, t_dml_upsert_sub0127.b                  |
|           Index Cond: (t_dml_upsert_sub0127.b = 4)                                |
|   ->  Result                                                                      |
|         Output: 2, '2'::text, 3, NULL::text                                       |
+-----------------------------------------------------------------------------------+
--CTE with子句，muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(3,3,4) on duplicate key update (c,d)= (with temp_tb(i,j,k) as(select a,c,b from t_dml_upsert_sub0127) select i,j from temp_tb where k = '7');
?.*ERROR: syntax error at or near "with temp_tb"
?.*
explain (costs off, verbose) with temp_tb(i,j,k) as(select a,c,b from t_dml_upsert_sub0127) select i from temp_tb where k = '7';
+---------------------------------------------------------------------------+
| QUERY PLAN                                                                |
+---------------------------------------------------------------------------+
| [Bypass]                                                                  |
| Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|   Output: t_dml_upsert_sub0127.a                                          |
|   Index Cond: (t_dml_upsert_sub0127.b = 7)                                |
+---------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(3,3,4) on duplicate key update c = (with temp_tb(i,j,k) as(select a,c,b from t_dml_upsert_sub0127) select i from temp_tb where k = '7');
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
| 2 | 2 | 4 |   |
| 3 | 3 | 7 |   |
+---+---+---+---+
explain (costs off, verbose) insert into t_dml_upsert0127 values(3,3,4) on duplicate key update c = (with temp_tb(i,j,k) as(select a,c,b from t_dml_upsert_sub0127) select i from temp_tb where k = '7');
+-----------------------------------------------------------------------------------+
| QUERY PLAN                                                                        |
+-----------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                 |
|   Conflict Resolution: UPDATE                                                     |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                 |
|   InitPlan 1 (returns $0)                                                         |
|     ->  Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|           Output: t_dml_upsert_sub0127.a                                          |
|           Index Cond: (t_dml_upsert_sub0127.b = 7)                                |
|   ->  Result                                                                      |
|         Output: 3, '3'::text, 4, NULL::text                                       |
+-----------------------------------------------------------------------------------+
--order by nulls ;muilt-set不支持，报错；single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) =(select a, avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>10 order by a nulls last);
?.*ERROR: syntax error at or near "order"
?.*
explain (costs off, verbose) select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls last limit 1;
+-------------------------------------------------------------------+
| QUERY PLAN                                                        |
+-------------------------------------------------------------------+
| Limit                                                             |
|   Output: (avg(b)), a                                             |
|   ->  Sort                                                        |
|         Output: (avg(b)), a                                       |
|         Sort Key: t_dml_upsert_sub0127.a                          |
|         ->  HashAggregate                                         |
|               Output: avg(b), a                                   |
|               Group By Key: t_dml_upsert_sub0127.a                |
|               Filter: (avg(t_dml_upsert_sub0127.b) > 13::numeric) |
|               ->  Seq Scan on public.t_dml_upsert_sub0127         |
|                     Output: a, b                                  |
+-------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d =(select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls last limit 1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d =(select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls last limit 1);
+------------------------------------------------------------------------------------+
| QUERY PLAN                                                                         |
+------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                  |
|   Conflict Resolution: UPDATE                                                      |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                  |
|   InitPlan 1 (returns $0)                                                          |
|     ->  Limit                                                                      |
|           Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a            |
|           ->  Sort                                                                 |
|                 Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a      |
|                 Sort Key: t_dml_upsert_sub0127.a                                   |
|                 ->  HashAggregate                                                  |
|                       Output: avg(t_dml_upsert_sub0127.b), t_dml_upsert_sub0127.a  |
|                       Group By Key: t_dml_upsert_sub0127.a                         |
|                       Filter: (avg(t_dml_upsert_sub0127.b) > 13::numeric)          |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                  |
|                             Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.b |
|   ->  Result                                                                       |
|         Output: 2, '2'::text, 3, NULL::text                                        |
+------------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+---------------------+
| a | b | c | d                   |
+---+---+---+---------------------+
| 4 | 4 | 4 |                     |
| 1 | 1 | 1 | 7                   |
| 3 | 3 | 7 |                     |
| 2 | 2 | 4 | 14.0000000000000000 |
+---+---+---+---------------------+
explain (costs off, verbose) select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls first limit 1;
+-------------------------------------------------------------------+
| QUERY PLAN                                                        |
+-------------------------------------------------------------------+
| Limit                                                             |
|   Output: (avg(b)), a                                             |
|   ->  Sort                                                        |
|         Output: (avg(b)), a                                       |
|         Sort Key: t_dml_upsert_sub0127.a NULLS FIRST              |
|         ->  HashAggregate                                         |
|               Output: avg(b), a                                   |
|               Group By Key: t_dml_upsert_sub0127.a                |
|               Filter: (avg(t_dml_upsert_sub0127.b) > 13::numeric) |
|               ->  Seq Scan on public.t_dml_upsert_sub0127         |
|                     Output: a, b                                  |
+-------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d =(select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls first limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---------------------+
| a | b | c | d                   |
+---+---+---+---------------------+
| 4 | 4 | 4 |                     |
| 1 | 1 | 1 | 7                   |
| 3 | 3 | 7 |                     |
| 2 | 2 | 4 | 25.5000000000000000 |
+---+---+---+---------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d =(select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>13 order by a nulls first limit 1);
+------------------------------------------------------------------------------------+
| QUERY PLAN                                                                         |
+------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                  |
|   Conflict Resolution: UPDATE                                                      |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                  |
|   InitPlan 1 (returns $0)                                                          |
|     ->  Limit                                                                      |
|           Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a            |
|           ->  Sort                                                                 |
|                 Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a      |
|                 Sort Key: t_dml_upsert_sub0127.a NULLS FIRST                       |
|                 ->  HashAggregate                                                  |
|                       Output: avg(t_dml_upsert_sub0127.b), t_dml_upsert_sub0127.a  |
|                       Group By Key: t_dml_upsert_sub0127.a                         |
|                       Filter: (avg(t_dml_upsert_sub0127.b) > 13::numeric)          |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                  |
|                             Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.b |
|   ->  Result                                                                       |
|         Output: 2, '2'::text, 3, NULL::text                                        |
+------------------------------------------------------------------------------------+
--group by having; muilt-set/single-set均支持
explain (costs off, verbose) select a,avg(b) from t_dml_upsert_sub0127 group by a having avg(b)=15;
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| HashAggregate                                         |
|   Output: a, avg(b)                                   |
|   Group By Key: t_dml_upsert_sub0127.a                |
|   Filter: (avg(t_dml_upsert_sub0127.b) = 15::numeric) |
|   ->  Seq Scan on public.t_dml_upsert_sub0127         |
|         Output: a, b                                  |
+-------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,avg(b) from t_dml_upsert_sub0127 group by a having avg(b)=15);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+----+---------------------+
| a | b | c  | d                   |
+---+---+----+---------------------+
| 4 | 4 | 4  |                     |
| 1 | 1 | 1  | 7                   |
| 3 | 3 | 7  |                     |
| 2 | 2 | 10 | 15.0000000000000000 |
+---+---+----+---------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,avg(b) from t_dml_upsert_sub0127 group by a having avg(b)=15);
+--------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                 |
+--------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                          |
|   Conflict Resolution: UPDATE                                                              |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                          |
|   InitPlan 1 (returns $0)                                                                  |
|     ->  Subquery Scan on "S"                                                               |
|           Output: "S".s1                                                                   |
|           ->  HashAggregate                                                                |
|                 Output: public.t_dml_upsert_sub0127.a, avg(public.t_dml_upsert_sub0127.b)  |
|                 Group By Key: public.t_dml_upsert_sub0127.a                                |
|                 Filter: (avg(public.t_dml_upsert_sub0127.b) = 15::numeric)                 |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                       Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b |
|   InitPlan 2 (returns $1)                                                                  |
|     ->  Subquery Scan on "S"                                                               |
|           Output: "S".s2                                                                   |
|           ->  HashAggregate                                                                |
|                 Output: public.t_dml_upsert_sub0127.a, avg(public.t_dml_upsert_sub0127.b)  |
|                 Group By Key: public.t_dml_upsert_sub0127.a                                |
|                 Filter: (avg(public.t_dml_upsert_sub0127.b) = 15::numeric)                 |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                       Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b |
|   ->  Result                                                                               |
|         Output: 2, '2'::text, 3, NULL::text                                                |
+--------------------------------------------------------------------------------------------+
explain (costs off, verbose) select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>10 order by a asc limit 1;
+-------------------------------------------------------------------+
| QUERY PLAN                                                        |
+-------------------------------------------------------------------+
| Limit                                                             |
|   Output: (avg(b)), a                                             |
|   ->  Sort                                                        |
|         Output: (avg(b)), a                                       |
|         Sort Key: t_dml_upsert_sub0127.a                          |
|         ->  HashAggregate                                         |
|               Output: avg(b), a                                   |
|               Group By Key: t_dml_upsert_sub0127.a                |
|               Filter: (avg(t_dml_upsert_sub0127.b) > 10::numeric) |
|               ->  Seq Scan on public.t_dml_upsert_sub0127         |
|                     Output: a, b                                  |
+-------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>10 order by a asc limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+----+---------------------+
| a | b | c  | d                   |
+---+---+----+---------------------+
| 4 | 4 | 4  |                     |
| 1 | 1 | 1  | 7                   |
| 3 | 3 | 7  |                     |
| 2 | 2 | 10 | 11.0000000000000000 |
+---+---+----+---------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select avg(b) from t_dml_upsert_sub0127 group by a having avg(b)>10 order by a asc limit 1);
+------------------------------------------------------------------------------------+
| QUERY PLAN                                                                         |
+------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                  |
|   Conflict Resolution: UPDATE                                                      |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                  |
|   InitPlan 1 (returns $0)                                                          |
|     ->  Limit                                                                      |
|           Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a            |
|           ->  Sort                                                                 |
|                 Output: (avg(t_dml_upsert_sub0127.b)), t_dml_upsert_sub0127.a      |
|                 Sort Key: t_dml_upsert_sub0127.a                                   |
|                 ->  HashAggregate                                                  |
|                       Output: avg(t_dml_upsert_sub0127.b), t_dml_upsert_sub0127.a  |
|                       Group By Key: t_dml_upsert_sub0127.a                         |
|                       Filter: (avg(t_dml_upsert_sub0127.b) > 10::numeric)          |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                  |
|                             Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.b |
|   ->  Result                                                                       |
|         Output: 2, '2'::text, 3, NULL::text                                        |
+------------------------------------------------------------------------------------+
--group by cube; muilt-set/single-set均支持
explain (costs off, verbose) select a,avg(b) from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 10;
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| GroupAggregate                                        |
|   Output: a, avg(b)                                   |
|   Group By Key: t_dml_upsert_sub0127.a                |
|   Group By Key: ()                                    |
|   Filter: (avg(t_dml_upsert_sub0127.b) = 10::numeric) |
|   ->  Sort                                            |
|         Output: a, b                                  |
|         Sort Key: t_dml_upsert_sub0127.a              |
|         ->  Seq Scan on public.t_dml_upsert_sub0127   |
|               Output: a, b                            |
+-------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,avg(b) from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 10);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---------------------+
| a | b | c | d                   |
+---+---+---+---------------------+
| 4 | 4 | 4 |                     |
| 1 | 1 | 1 | 7                   |
| 3 | 3 | 7 |                     |
| 2 | 2 | 5 | 10.0000000000000000 |
+---+---+---+---------------------+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,avg(b) from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 10);
+--------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                       |
+--------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                                |
|   Conflict Resolution: UPDATE                                                                    |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                                |
|   InitPlan 1 (returns $0)                                                                        |
|     ->  Subquery Scan on "S"                                                                     |
|           Output: "S".s1                                                                         |
|           ->  GroupAggregate                                                                     |
|                 Output: public.t_dml_upsert_sub0127.a, avg(public.t_dml_upsert_sub0127.b)        |
|                 Group By Key: public.t_dml_upsert_sub0127.a                                      |
|                 Group By Key: ()                                                                 |
|                 Filter: (avg(public.t_dml_upsert_sub0127.b) = 10::numeric)                       |
|                 ->  Sort                                                                         |
|                       Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b       |
|                       Sort Key: public.t_dml_upsert_sub0127.a                                    |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                             Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b |
|   InitPlan 2 (returns $1)                                                                        |
|     ->  Subquery Scan on "S"                                                                     |
|           Output: "S".s2                                                                         |
|           ->  GroupAggregate                                                                     |
|                 Output: public.t_dml_upsert_sub0127.a, avg(public.t_dml_upsert_sub0127.b)        |
|                 Group By Key: public.t_dml_upsert_sub0127.a                                      |
|                 Group By Key: ()                                                                 |
|                 Filter: (avg(public.t_dml_upsert_sub0127.b) = 10::numeric)                       |
|                 ->  Sort                                                                         |
|                       Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b       |
|                       Sort Key: public.t_dml_upsert_sub0127.a                                    |
|                       ->  Seq Scan on public.t_dml_upsert_sub0127                                |
|                             Output: public.t_dml_upsert_sub0127.a, public.t_dml_upsert_sub0127.b |
|   ->  Result                                                                                     |
|         Output: 2, '2'::text, 3, NULL::text                                                      |
+--------------------------------------------------------------------------------------------------+
explain (costs off, verbose) select a from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 11;
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| GroupAggregate                                        |
|   Output: a                                           |
|   Group By Key: t_dml_upsert_sub0127.a                |
|   Group By Key: ()                                    |
|   Filter: (avg(t_dml_upsert_sub0127.b) = 11::numeric) |
|   ->  Sort                                            |
|         Output: a, b                                  |
|         Sort Key: t_dml_upsert_sub0127.a              |
|         ->  Seq Scan on public.t_dml_upsert_sub0127   |
|               Output: a, b                            |
+-------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select a from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 11);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
| 3 | 3 | 7 |   |
| 2 | 2 | 5 | 6 |
+---+---+---+---+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select a from t_dml_upsert_sub0127 group by CUBE(a) having avg(b)= 11);
+------------------------------------------------------------------------------+
| QUERY PLAN                                                                   |
+------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                            |
|   Conflict Resolution: UPDATE                                                |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                            |
|   InitPlan 1 (returns $0)                                                    |
|     ->  GroupAggregate                                                       |
|           Output: t_dml_upsert_sub0127.a                                     |
|           Group By Key: t_dml_upsert_sub0127.a                               |
|           Group By Key: ()                                                   |
|           Filter: (avg(t_dml_upsert_sub0127.b) = 11::numeric)                |
|           ->  Sort                                                           |
|                 Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.b       |
|                 Sort Key: t_dml_upsert_sub0127.a                             |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                  |
|                       Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.b |
|   ->  Result                                                                 |
|         Output: 2, '2'::text, 3, NULL::text                                  |
+------------------------------------------------------------------------------+
--window ;muilt-set不支持/single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select b,count(c) over window1 typecount from t_dml_upsert_sub0127 where b =11 window window1 as (partition by a));
?.*ERROR: syntax error at or near "window"
?.*
explain (costs off, verbose) select count(c) over window1 typecount from t_dml_upsert_sub0127 where b =11 window window1 as (partition by a);
+---------------------------------------------------------------------------------------+
| QUERY PLAN                                                                            |
+---------------------------------------------------------------------------------------+
| WindowAgg                                                                             |
|   Output: count(c) OVER (PARTITION BY a), a                                           |
|   ->  Sort                                                                            |
|         Output: a, c                                                                  |
|         Sort Key: t_dml_upsert_sub0127.a                                              |
|         ->  Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127 |
|               Output: a, c                                                            |
|               Index Cond: (t_dml_upsert_sub0127.b = 11)                               |
+---------------------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update c = (select count(c) over window1 typecount from t_dml_upsert_sub0127 where b =11 window window1 as (partition by a));
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
| 3 | 3 | 7 |   |
| 2 | 2 | 1 | 6 |
+---+---+---+---+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update c = (select count(c) over window1 typecount from t_dml_upsert_sub0127 where b =11 window window1 as (partition by a));
+--------------------------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                                         |
+--------------------------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                                                  |
|   Conflict Resolution: UPDATE                                                                                      |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                                                  |
|   InitPlan 1 (returns $0)                                                                                          |
|     ->  WindowAgg                                                                                                  |
|           Output: count(t_dml_upsert_sub0127.c) OVER (PARTITION BY t_dml_upsert_sub0127.a), t_dml_upsert_sub0127.a |
|           ->  Sort                                                                                                 |
|                 Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.c                                             |
|                 Sort Key: t_dml_upsert_sub0127.a                                                                   |
|                 ->  Index Scan using t_dml_upsert_sub0127_pkey on public.t_dml_upsert_sub0127                      |
|                       Output: t_dml_upsert_sub0127.a, t_dml_upsert_sub0127.c                                       |
|                       Index Cond: (t_dml_upsert_sub0127.b = 11)                                                    |
|   ->  Result                                                                                                       |
|         Output: 2, '2'::text, 3, NULL::text                                                                        |
+--------------------------------------------------------------------------------------------------------------------+
--union ;muilt-set不支持/single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,b from t_dml_upsert_sub0127 where a =1 union select a,b from t_dml_upsert_sub0127 where a = 2);
?.*ERROR: syntax error at or near "union"
?.*
explain (costs off, verbose) select b from t_dml_upsert_sub0127 where a =1 union select b from t_dml_upsert_sub0127 where a = 2 order by b desc limit 1;
+-----------------------------------------------------------------------+
| QUERY PLAN                                                            |
+-----------------------------------------------------------------------+
| Limit                                                                 |
|   Output: public.t_dml_upsert_sub0127.b                               |
|   ->  Sort                                                            |
|         Output: public.t_dml_upsert_sub0127.b                         |
|         Sort Key: public.t_dml_upsert_sub0127.b DESC                  |
|         ->  HashAggregate                                             |
|               Output: public.t_dml_upsert_sub0127.b                   |
|               Group By Key: public.t_dml_upsert_sub0127.b             |
|               ->  Append                                              |
|                     ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                           Output: public.t_dml_upsert_sub0127.b       |
|                           Filter: (public.t_dml_upsert_sub0127.a = 1) |
|                     ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                           Output: public.t_dml_upsert_sub0127.b       |
|                           Filter: (public.t_dml_upsert_sub0127.a = 2) |
+-----------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select b from t_dml_upsert_sub0127 where a =1 union select b from t_dml_upsert_sub0127 where a = 2 order by b desc limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+----+
| a | b | c | d  |
+---+---+---+----+
| 4 | 4 | 4 |    |
| 1 | 1 | 1 | 7  |
| 3 | 3 | 7 |    |
| 2 | 2 | 1 | 12 |
+---+---+---+----+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select b from t_dml_upsert_sub0127 where a =1 union select b from t_dml_upsert_sub0127 where a = 2 order by b desc limit 1);
+-------------------------------------------------------------------------------+
| QUERY PLAN                                                                    |
+-------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                             |
|   Conflict Resolution: UPDATE                                                 |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                             |
|   InitPlan 1 (returns $0)                                                     |
|     ->  Limit                                                                 |
|           Output: public.t_dml_upsert_sub0127.b                               |
|           ->  Sort                                                            |
|                 Output: public.t_dml_upsert_sub0127.b                         |
|                 Sort Key: public.t_dml_upsert_sub0127.b DESC                  |
|                 ->  HashAggregate                                             |
|                       Output: public.t_dml_upsert_sub0127.b                   |
|                       Group By Key: public.t_dml_upsert_sub0127.b             |
|                       ->  Append                                              |
|                             ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                   Output: public.t_dml_upsert_sub0127.b       |
|                                   Filter: (public.t_dml_upsert_sub0127.a = 1) |
|                             ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                   Output: public.t_dml_upsert_sub0127.b       |
|                                   Filter: (public.t_dml_upsert_sub0127.a = 2) |
|   ->  Result                                                                  |
|         Output: 2, '2'::text, 3, NULL::text                                   |
+-------------------------------------------------------------------------------+
--except ;muilt-set不支持/single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,c from t_dml_upsert_sub0127 where b>3 except select a,c from t_dml_upsert_sub0127 where b>4);
?.*ERROR: syntax error at or near "except"
?.*
explain (costs off, verbose) select c from t_dml_upsert_sub0127 where b>3 except select c from t_dml_upsert_sub0127 where a = 4 order by c desc limit 1;
+-----------------------------------------------------------------------------+
| QUERY PLAN                                                                  |
+-----------------------------------------------------------------------------+
| Limit                                                                       |
|   Output: "*SELECT* 1".c, (0)                                               |
|   ->  Sort                                                                  |
|         Output: "*SELECT* 1".c, (0)                                         |
|         Sort Key: "*SELECT* 1".c DESC                                       |
|         ->  HashSetOp Except                                                |
|               Output: "*SELECT* 1".c, (0)                                   |
|               ->  Append                                                    |
|                     ->  Subquery Scan on "*SELECT* 1"                       |
|                           Output: "*SELECT* 1".c, 0                         |
|                           ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                 Output: public.t_dml_upsert_sub0127.c       |
|                                 Filter: (public.t_dml_upsert_sub0127.b > 3) |
|                     ->  Subquery Scan on "*SELECT* 2"                       |
|                           Output: "*SELECT* 2".c, 1                         |
|                           ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                 Output: public.t_dml_upsert_sub0127.c       |
|                                 Filter: (public.t_dml_upsert_sub0127.a = 4) |
+-----------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where b>3 except select c from t_dml_upsert_sub0127 where a = 4 order by c desc limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 4 | 4 | 4 |     |
| 1 | 1 | 1 | 7   |
| 3 | 3 | 7 |     |
| 2 | 2 | 1 | c-9 |
+---+---+---+-----+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where b>3 except select c from t_dml_upsert_sub0127 where a = 4 order by c desc limit 1);
+-------------------------------------------------------------------------------------+
| QUERY PLAN                                                                          |
+-------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                   |
|   Conflict Resolution: UPDATE                                                       |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                   |
|   InitPlan 1 (returns $0)                                                           |
|     ->  Limit                                                                       |
|           Output: "*SELECT* 1".c, (0)                                               |
|           ->  Sort                                                                  |
|                 Output: "*SELECT* 1".c, (0)                                         |
|                 Sort Key: "*SELECT* 1".c DESC                                       |
|                 ->  HashSetOp Except                                                |
|                       Output: "*SELECT* 1".c, (0)                                   |
|                       ->  Append                                                    |
|                             ->  Subquery Scan on "*SELECT* 1"                       |
|                                   Output: "*SELECT* 1".c, 0                         |
|                                   ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                         Output: public.t_dml_upsert_sub0127.c       |
|                                         Filter: (public.t_dml_upsert_sub0127.b > 3) |
|                             ->  Subquery Scan on "*SELECT* 2"                       |
|                                   Output: "*SELECT* 2".c, 1                         |
|                                   ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                         Output: public.t_dml_upsert_sub0127.c       |
|                                         Filter: (public.t_dml_upsert_sub0127.a = 4) |
|   ->  Result                                                                        |
|         Output: 2, '2'::text, 3, NULL::text                                         |
+-------------------------------------------------------------------------------------+
--intersect ;muilt-set不支持/single-set支持
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update (c,d) = (select a,c from t_dml_upsert_sub0127 where b>3 intersect select a,c from t_dml_upsert_sub0127 where b>4);
?.*ERROR: syntax error at or near "intersect"
?.*
explain (costs off, verbose) select c from t_dml_upsert_sub0127 where b>3 intersect select c from t_dml_upsert_sub0127 where a < 4 order by c desc limit 1;
+-----------------------------------------------------------------------------+
| QUERY PLAN                                                                  |
+-----------------------------------------------------------------------------+
| Limit                                                                       |
|   Output: "*SELECT* 2".c, (1)                                               |
|   ->  Sort                                                                  |
|         Output: "*SELECT* 2".c, (1)                                         |
|         Sort Key: "*SELECT* 2".c DESC                                       |
|         ->  HashSetOp Intersect                                             |
|               Output: "*SELECT* 2".c, (1)                                   |
|               ->  Append                                                    |
|                     ->  Subquery Scan on "*SELECT* 2"                       |
|                           Output: "*SELECT* 2".c, 1                         |
|                           ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                 Output: public.t_dml_upsert_sub0127.c       |
|                                 Filter: (public.t_dml_upsert_sub0127.a < 4) |
|                     ->  Subquery Scan on "*SELECT* 1"                       |
|                           Output: "*SELECT* 1".c, 0                         |
|                           ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                 Output: public.t_dml_upsert_sub0127.c       |
|                                 Filter: (public.t_dml_upsert_sub0127.b > 3) |
+-----------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where b>3 intersect select c from t_dml_upsert_sub0127 where a < 4 order by c desc limit 1);
SQL SUCCESS
select * from t_dml_upsert0127;
+---+---+---+-----+
| a | b | c | d   |
+---+---+---+-----+
| 4 | 4 | 4 |     |
| 1 | 1 | 1 | 7   |
| 3 | 3 | 7 |     |
| 2 | 2 | 1 | c-3 |
+---+---+---+-----+
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d = (select c from t_dml_upsert_sub0127 where b>3 intersect select c from t_dml_upsert_sub0127 where a < 4 order by c desc limit 1);
+-------------------------------------------------------------------------------------+
| QUERY PLAN                                                                          |
+-------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                   |
|   Conflict Resolution: UPDATE                                                       |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                   |
|   InitPlan 1 (returns $0)                                                           |
|     ->  Limit                                                                       |
|           Output: "*SELECT* 2".c, (1)                                               |
|           ->  Sort                                                                  |
|                 Output: "*SELECT* 2".c, (1)                                         |
|                 Sort Key: "*SELECT* 2".c DESC                                       |
|                 ->  HashSetOp Intersect                                             |
|                       Output: "*SELECT* 2".c, (1)                                   |
|                       ->  Append                                                    |
|                             ->  Subquery Scan on "*SELECT* 2"                       |
|                                   Output: "*SELECT* 2".c, 1                         |
|                                   ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                         Output: public.t_dml_upsert_sub0127.c       |
|                                         Filter: (public.t_dml_upsert_sub0127.a < 4) |
|                             ->  Subquery Scan on "*SELECT* 1"                       |
|                                   Output: "*SELECT* 1".c, 0                         |
|                                   ->  Seq Scan on public.t_dml_upsert_sub0127       |
|                                         Output: public.t_dml_upsert_sub0127.c       |
|                                         Filter: (public.t_dml_upsert_sub0127.b > 3) |
|   ->  Result                                                                        |
|         Output: 2, '2'::text, 3, NULL::text                                         |
+-------------------------------------------------------------------------------------+
--order by NLS_SORT ;single-set支持
insert into t_dml_upsert_sub0127 values(generate_series(1,10),generate_series(31,40),'C-'||generate_series(1,10));
SQL SUCCESS
explain (costs off, verbose) select b from t_dml_upsert_sub0127 order by NLSSORT( c, 'NLS_SORT = generic_m_ci') limit 1;
+--------------------------------------------------------------------------------------+
| QUERY PLAN                                                                           |
+--------------------------------------------------------------------------------------+
| Limit                                                                                |
|   Output: b, (nlssort(c, 'NLS_SORT = generic_m_ci'::text))                           |
|   ->  Sort                                                                           |
|         Output: b, (nlssort(c, 'NLS_SORT = generic_m_ci'::text))                     |
|         Sort Key: (nlssort(t_dml_upsert_sub0127.c, 'NLS_SORT = generic_m_ci'::text)) |
|         ->  Seq Scan on public.t_dml_upsert_sub0127                                  |
|               Output: b, nlssort(c, 'NLS_SORT = generic_m_ci'::text)                 |
+--------------------------------------------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 order by NLSSORT( c, 'NLS_SORT = generic_m_ci') limit 1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 order by NLSSORT( c, 'NLS_SORT = generic_m_ci') limit 1);
+------------------------------------------------------------------------------------------------------------------------+
| QUERY PLAN                                                                                                             |
+------------------------------------------------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                                                                      |
|   Conflict Resolution: UPDATE                                                                                          |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                                                                      |
|   InitPlan 1 (returns $0)                                                                                              |
|     ->  Limit                                                                                                          |
|           Output: t_dml_upsert_sub0127.b, (nlssort(t_dml_upsert_sub0127.c, 'NLS_SORT = generic_m_ci'::text))           |
|           ->  Sort                                                                                                     |
|                 Output: t_dml_upsert_sub0127.b, (nlssort(t_dml_upsert_sub0127.c, 'NLS_SORT = generic_m_ci'::text))     |
|                 Sort Key: (nlssort(t_dml_upsert_sub0127.c, 'NLS_SORT = generic_m_ci'::text))                           |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                                                            |
|                       Output: t_dml_upsert_sub0127.b, nlssort(t_dml_upsert_sub0127.c, 'NLS_SORT = generic_m_ci'::text) |
|   ->  Result                                                                                                           |
|         Output: 2, '2'::text, 3, NULL::text                                                                            |
+------------------------------------------------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 4 | 4 | 4 |   |
| 1 | 1 | 1 | 7 |
| 3 | 3 | 7 |   |
| 2 | 2 | 1 | 1 |
+---+---+---+---+
explain (costs off, verbose) select b from t_dml_upsert_sub0127 order by c limit 1;
+-----------------------------------------------------+
| QUERY PLAN                                          |
+-----------------------------------------------------+
| Limit                                               |
|   Output: b, c                                      |
|   ->  Sort                                          |
|         Output: b, c                                |
|         Sort Key: t_dml_upsert_sub0127.c            |
|         ->  Seq Scan on public.t_dml_upsert_sub0127 |
|               Output: b, c                          |
+-----------------------------------------------------+
insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 order by c limit 1);
SQL SUCCESS
explain (costs off, verbose) insert into t_dml_upsert0127 values(2,2,3) on duplicate key update d= (select b from t_dml_upsert_sub0127 order by c limit 1);
+------------------------------------------------------------------------------+
| QUERY PLAN                                                                   |
+------------------------------------------------------------------------------+
| Insert on public.t_dml_upsert0127                                            |
|   Conflict Resolution: UPDATE                                                |
|   Conflict Arbiter Indexes: t_dml_upsert0127_pkey                            |
|   InitPlan 1 (returns $0)                                                    |
|     ->  Limit                                                                |
|           Output: t_dml_upsert_sub0127.b, t_dml_upsert_sub0127.c             |
|           ->  Sort                                                           |
|                 Output: t_dml_upsert_sub0127.b, t_dml_upsert_sub0127.c       |
|                 Sort Key: t_dml_upsert_sub0127.c                             |
|                 ->  Seq Scan on public.t_dml_upsert_sub0127                  |
|                       Output: t_dml_upsert_sub0127.b, t_dml_upsert_sub0127.c |
|   ->  Result                                                                 |
|         Output: 2, '2'::text, 3, NULL::text                                  |
+------------------------------------------------------------------------------+
select * from t_dml_upsert0127;
+---+---+---+----+
| a | b | c | d  |
+---+---+---+----+
| 4 | 4 | 4 |    |
| 1 | 1 | 1 | 7  |
| 3 | 3 | 7 |    |
| 2 | 2 | 1 | 31 |
+---+---+---+----+
--for update ;muilt-set不支持/single-set支持
insert into t_dml_upsert0127 values(2) on duplicate key update (b,c) = (select b,c from t_dml_upsert_sub0127 where a = excluded.a for update);
?.*ERROR: syntax error at or near "for"
?.*
insert into t_dml_upsert0127 values(2) on duplicate key update b= (select b from t_dml_upsert_sub0127 where a = excluded.a for update);
?.*ERROR: INSERT ON DUPLICATE KEY UPDATE don't allow update on primary key or unique key.
select * from t_dml_upsert0127;
+---+---+---+----+
| a | b | c | d  |
+---+---+---+----+
| 4 | 4 | 4 |    |
| 1 | 1 | 1 | 7  |
| 3 | 3 | 7 |    |
| 2 | 2 | 1 | 31 |
+---+---+---+----+
--数据处理
drop table if exists t_dml_upsert0127;
SQL SUCCESS
drop table if exists t_dml_upsert_sub0127;
SQL SUCCESS
